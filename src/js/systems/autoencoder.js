// Runtime helper for encoding minions using a trained sparse autoencoder.
// We lazily load data/models/autoencoder.json (generated by tools/train-autoencoder.mjs)
// and expose encodeMinion(minion) -> latent vector.

const DEFAULT_COLUMNS = Object.freeze([
  'attack',
  'health',
  'taunt',
  'rush',
  'charge',
  'stealth',
  'divineShield',
  'windfury',
  'reflect',
  'lifesteal'
]);

const DEFAULT_MAX_HINTS = Object.freeze({
  attack: 20,
  health: 20,
  taunt: 1,
  rush: 1,
  charge: 1,
  stealth: 1,
  divineShield: 1,
  windfury: 1,
  reflect: 1,
  lifesteal: 1,
});

export const DEFAULT_LATENT_SIZE = 20;

let AutoencoderModel = null;
let LoadPromise = null;
let LoadError = null;

function clamp01(x) {
  if (Number.isNaN(x)) return 0;
  if (x < 0) return 0;
  if (x > 1) return 1;
  return x;
}

function numberOrZero(value) {
  const n = Number(value);
  return Number.isFinite(n) ? n : 0;
}

function keywordActive(card, keyword) {
  if (!card) return false;
  if (Array.isArray(card.keywords) && card.keywords.includes(keyword)) return true;
  const tempCounts = card?.data?.tempKeywordCounts;
  if (tempCounts && numberOrZero(tempCounts[keyword]) > 0) return true;
  return false;
}

function divineShieldActive(card) {
  if (!card) return false;
  if (card?.data?.divineShield === true) return true;
  if (card?.data?.divineShield === false) return false;
  return keywordActive(card, 'Divine Shield');
}

function extractFeature(card, column) {
  switch (column) {
    case 'attack':
      return numberOrZero(card?.data?.attack ?? card?.attack);
    case 'health':
      return numberOrZero(card?.data?.health ?? card?.health);
    case 'taunt':
      return keywordActive(card, 'Taunt') ? 1 : 0;
    case 'rush':
      return keywordActive(card, 'Rush') ? 1 : 0;
    case 'charge':
      return keywordActive(card, 'Charge') ? 1 : 0;
    case 'stealth':
      return keywordActive(card, 'Stealth') ? 1 : 0;
    case 'divineShield':
      return divineShieldActive(card) ? 1 : 0;
    case 'windfury':
      return keywordActive(card, 'Windfury') ? 1 : 0;
    case 'reflect':
      return keywordActive(card, 'Reflect') ? 1 : 0;
    case 'lifesteal':
      return keywordActive(card, 'Lifesteal') ? 1 : 0;
    default:
      return 0;
  }
}

function minionFeatureVector(minion, columns = DEFAULT_COLUMNS) {
  if (!minion) return columns.map(() => 0);
  return columns.map((col) => extractFeature(minion, col));
}

function fallbackMaxForColumn(column) {
  return DEFAULT_MAX_HINTS[column] || 1;
}

function normalizeFeatures(raw, { columns = DEFAULT_COLUMNS, featureStats = null } = {}) {
  const maxList = featureStats?.max;
  return raw.map((value, idx) => {
    const column = columns[idx] || DEFAULT_COLUMNS[idx] || 'attack';
    const max = (Array.isArray(maxList) && maxList[idx] > 0)
      ? maxList[idx]
      : fallbackMaxForColumn(column);
    return clamp01((value || 0) / max);
  });
}

function applyLayer(weights, biases, input) {
  const out = new Array(weights.length);
  for (let i = 0; i < weights.length; i++) {
    const row = weights[i] || [];
    let sum = Array.isArray(biases) ? (biases[i] || 0) : 0;
    const n = Math.min(row.length, input.length);
    for (let j = 0; j < n; j++) sum += row[j] * input[j];
    out[i] = sum;
  }
  return out;
}

function applyActivation(name, vector) {
  if (!Array.isArray(vector)) return [];
  switch (name) {
    case 'relu':
      return vector.map((v) => (v > 0 ? v : 0));
    case 'sigmoid':
      return vector.map((v) => 1 / (1 + Math.exp(-v)));
    case 'tanh':
      return vector.map((v) => Math.tanh(v));
    case 'linear':
    default:
      return vector.slice();
  }
}

function runEncoder(input, model) {
  if (!model || !Array.isArray(model.encoder)) return [];
  let activation = input;
  for (const layer of model.encoder) {
    if (!layer) continue;
    const weights = Array.isArray(layer.weights) ? layer.weights : [];
    const biases = Array.isArray(layer.biases) ? layer.biases : [];
    const actName = layer.activation || 'linear';
    const projected = applyLayer(weights, biases, activation);
    activation = applyActivation(actName, projected);
  }
  return activation;
}

function padVector(vec, size) {
  const out = new Array(size).fill(0);
  if (!Array.isArray(vec)) return out;
  const n = Math.min(size, vec.length);
  for (let i = 0; i < n; i++) out[i] = Number(vec[i]) || 0;
  return out;
}

function defaultNormalized(raw, columns = DEFAULT_COLUMNS) {
  const defaults = columns.map((column) => fallbackMaxForColumn(column));
  const stats = { max: defaults };
  return normalizeFeatures(raw, { columns, featureStats: stats });
}

function fallbackEncode(raw, columns) {
  const normalized = defaultNormalized(raw, columns);
  const latentSize = DEFAULT_LATENT_SIZE;
  const out = new Array(latentSize).fill(0);
  if (!normalized.length) return out;
  for (let i = 0; i < latentSize; i++) {
    out[i] = normalized[i % normalized.length] || 0;
  }
  return out;
}

function sanitizeModel(raw) {
  if (!raw || typeof raw !== 'object') return null;
  const columns = Array.isArray(raw.columns) && raw.columns.length ? raw.columns.slice() : DEFAULT_COLUMNS.slice();
  const encoder = Array.isArray(raw.encoder) ? raw.encoder.map((layer) => ({
    weights: Array.isArray(layer?.weights) ? layer.weights.map((row) => row.slice()) : [],
    biases: Array.isArray(layer?.biases) ? layer.biases.slice() : [],
    activation: layer?.activation || 'linear',
  })) : [];
  if (!encoder.length) return null;
  const featureStats = {
    max: Array.isArray(raw?.featureStats?.max) ? raw.featureStats.max.slice() : null,
  };
  const columnSet = new Set(columns);
  let columnsChanged = false;
  for (const key of DEFAULT_COLUMNS) {
    if (!columnSet.has(key)) {
      columns.push(key);
      columnSet.add(key);
      columnsChanged = true;
    }
  }
  if (!Array.isArray(featureStats.max)) {
    featureStats.max = columns.map((column) => fallbackMaxForColumn(column));
  } else {
    while (featureStats.max.length < columns.length) {
      const column = columns[featureStats.max.length] || DEFAULT_COLUMNS[featureStats.max.length] || 'attack';
      featureStats.max.push(fallbackMaxForColumn(column));
    }
  }
  if (columnsChanged && encoder.length) {
    const expectedInputs = columns.length;
    const first = encoder[0];
    const weights = Array.isArray(first?.weights) ? first.weights : null;
    if (Array.isArray(weights)) {
      for (const row of weights) {
        if (!Array.isArray(row)) continue;
        while (row.length < expectedInputs) row.push(0);
      }
    }
  }
  const latentSize = Number(raw.latentSize) > 0 ? Math.floor(raw.latentSize) : DEFAULT_LATENT_SIZE;
  return {
    inputSize: columns.length,
    latentSize,
    encoder,
    columns,
    featureStats,
  };
}

async function fetchModel() {
  let data = null;
  if (typeof window === 'undefined') {
    const fs = await import('fs/promises');
    const url = new URL('../../../data/models/autoencoder.json', import.meta.url);
    const txt = await fs.readFile(url, 'utf8');
    data = JSON.parse(txt);
  } else {
    const res = await fetch(new URL('../../../data/models/autoencoder.json', import.meta.url));
    if (!res.ok) throw new Error(`Failed to fetch autoencoder model: ${res.status}`);
    data = await res.json();
  }
  const model = sanitizeModel(data);
  if (!model) throw new Error('Invalid autoencoder model file');
  return model;
}

export async function loadAutoencoder() {
  if (AutoencoderModel) return AutoencoderModel;
  if (LoadError) throw LoadError;
  if (!LoadPromise) {
    LoadPromise = fetchModel()
      .then((model) => {
        AutoencoderModel = model;
        return model;
      })
      .catch((err) => {
        LoadError = err;
        AutoencoderModel = null;
        throw err;
      });
  }
  return LoadPromise;
}

function getModel() {
  if (AutoencoderModel) return AutoencoderModel;
  return null;
}

export function isAutoencoderLoaded() {
  return !!AutoencoderModel;
}

export function getLatentSize() {
  if (AutoencoderModel?.latentSize) return AutoencoderModel.latentSize;
  return DEFAULT_LATENT_SIZE;
}

export function encodeMinion(minion) {
  const model = getModel();
  const columns = model?.columns || DEFAULT_COLUMNS;
  const raw = minionFeatureVector(minion, columns);
  if (!model) {
    return fallbackEncode(raw, columns);
  }
  const normalized = normalizeFeatures(raw, { columns, featureStats: model.featureStats });
  const encoded = runEncoder(normalized, model);
  return padVector(encoded, model.latentSize || DEFAULT_LATENT_SIZE);
}

export function resetAutoencoderCache() {
  AutoencoderModel = null;
  LoadPromise = null;
  LoadError = null;
}

export function rawMinionFeatures(minion) {
  return minionFeatureVector(minion, AutoencoderModel?.columns || DEFAULT_COLUMNS);
}
